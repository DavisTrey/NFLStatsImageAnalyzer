import java.awt.image.BufferedImage;
import java.awt.image.DataBufferByte;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URISyntaxException;
import java.net.URL;

import javax.imageio.ImageIO;

/**
 * Analyzes NFL game probability data. Loads a probability curve
 * such as http://live.advancednflstats.com/index.php?gameid1=2014092500
 * Parses bit data of the image to compute the integral of the curve. 
 * 
 * To use:
 * 1. Put screenshots of the probability curves into the ProbabilityImages folder
 * 2. Name the screenshots Team 1 vs. Team 2, where the BOTTOM team
 * on the graph is Team 1 (this is so the output is correct)
 * 3. The program will print out the relative win integrals for each team. 
 * IE, if the Redskins get an 84.5%, it means they effectively "won" 84.5% of the
 * game. 
 * @author Davis Treybig
 *
 */
public class ImageParser {
	public static final String imageFolder = "/ProbabilityImages";
	public ImageParser(){	
	}
	
	/**
	 * Loads every image in the designated images folder. Parses each
	 * to compute a probability integral for each image
	 */
	public void loadAndParseImages(){
		URL resource = ImageParser.class
			      .getResource(imageFolder);
		File folder;
		try {
		  folder = new File(resource.toURI());
		} catch(URISyntaxException e) {
		  folder = new File(resource.getPath());
		}
		for(final File imageFile: folder.listFiles()){
			double[] pixelValues = parseImage(imageFile);
			if(pixelValues != null){
				String filename = imageFile.getName();
				calculateAndPrintIntegrals(filename, pixelValues);
			}	
		}
	}
	
	/**
	 * Calculates the overall integrals from the pixelValue data, then prints
	 * out data from the game
	 * @param fileName Name of picture file (Should be in format "Team1 vs. Team2"
	 * @param pixelValues The pixel height at which the probability curve existed
	 * for each column of pixel data
	 */
	public void calculateAndPrintIntegrals(String fileName, double[] pixelValues){
		double cumSum = 0;
		for(int i=0; i<pixelValues.length; i++){
			cumSum = cumSum + pixelValues[i];
		}
		double ratio = cumSum / (pixelValues.length);
		double secondRatio = 1 - ratio;
		String[] splitName = fileName.split(" ");
		
		System.out.println("******* " + fileName + " *******");
		System.out.println(splitName[0] + ": " + ratio);
		System.out.println(splitName[2] + ": " + secondRatio);
		if(ratio > secondRatio){
			double relativeRatio = ratio / secondRatio;
			System.out.println(splitName[0] + " played " + relativeRatio + "% better");
		}
		else{
			double relativeRatio = secondRatio / ratio;
			System.out.println(splitName[1] + " played " + relativeRatio + "% better");
		}	
	}
	/**
	 * Takes the image, and finds the relative vertical location 
	 * of the yellow line pixel on each pixel column of the picture
	 * @param f Picture to be analyzed
	 */
	public double[] parseImage(File f){
		String filename = f.getName();
		
		BufferedImage img = null;
		try {
		    img = ImageIO.read(f);
		} catch (IOException e) {		
		}
		
		if(img != null){
			int[][] pixels = getPixels(img);
			
			//Represent the percentile height where the yellow pixel is on each column
			double[] yValues = new double[img.getWidth()];
			
			//Move pixel by pixel to the right. Use max height value - j
			//because that is the "bottom" of the image
			for(int i=0; i<img.getWidth(); i++){
				for(int j=0; j<img.getHeight(); j++){
					int currentPixel = pixels[i][img.getHeight()-1-j];
					int  red = (currentPixel & 0x00ff0000) >> 16;
					int  green = (currentPixel & 0x0000ff00) >> 8;
					int  blue = currentPixel & 0x000000ff;
					
					//The yellow color is R=248 G=255 B=0. We use ranges
					//to account for small variances in color
					if(red>240 && green>240 && blue<10){
						double position = j;
						double height = img.getHeight();
						yValues[i] = position/height;
						break;
					}
					//hit max pixel and didn't find yellow
					if(j==img.getHeight()-1){
						yValues[i] = -1; //filler value
					}
				}	
			}
			
			yValues = fillInMissingPixels(yValues);
			return yValues; 
		}
		else{
			System.out.println("Error reading file. Please check image");
			return null;
		}	
	}
	
	/**
	 * Cleans up up the pixel data generated by analyzing a graph. Specifically, 
	 * does three things
	 * 1. Fills in 0s from the first column onwards until 2 consecutive 
	 * yellow pixels have been found. This counteracts accidentally cropping
	 * the image too wide at the left
	 * 2. Fills in 0s from the last column leftwards until 2 consecutive
	 * yellow pixels have been found. This counteracts accidentially cropping
	 * the image too wide at the right
	 * 3. Fills missing data in the middle of the graph's range by averaging
	 * nearby values
	 * @param array Array of pixels
	 * @return Cleaned array of pixels
	 */
	public double[] fillInMissingPixels(double[] array){
		//Cascade zeros in the front to account for bad cropping. 
		//Assumes we have hit the graph once we see 2 yellow pixels in a row
		int count = 0;
		for(int i=0; i<array.length; i++){
			if(array[i] == -1){
				array[i] = 0;
				count = 0;
			}
			else{
				count++;
			}
			if(count >= 2){
				break;
			}
		}
		//Cascade zeros in the back to account for bad cropping. 
		//Assumes we have hit graph once we see 2 yellow pixels in a row
		for(int i=array.length-1; i>=0; i--){
			if(array[i] == -1){
				array[i] = 0;
				count = 0;
			}
			else{
				count++;
			}
			if(count >= 2){
				break;
			}
		}
		
		//Fill in missing data. If the next pixel was not found, just set
		//equal to the last pixel. Else, average the two nearby pixels
		for(int i=0; i<array.length; i++){
			if(array[i] == -1){
				if(array[i+1] == -1){
					array[i] = array[i-1];
				}
				else{
					array[i] = (array[i-1]+array[i+1])/2;
				}
			}
		}
		return array;
	}
	
	/**
	 * Populates a grid of pixels from a buffered image
	 */
	public int[][] getPixels(BufferedImage img){
		int[][] pixels = new int[img.getWidth()][img.getHeight()];
		for( int i = 0; i < img.getWidth(); i++ ){
		    for( int j = 0; j < img.getHeight(); j++ ){
		        pixels[i][j] = img.getRGB( i, j );
		    }
		}
		return pixels;
	}
	
	public static void main(String[] args){
		ImageParser parser = new ImageParser();
		parser.loadAndParseImages();
	}
}
